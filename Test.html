<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>color</title>
  <style>
    #container {
      width:100%;
      height:100%;
      background:#000000;
    }
  </style>
</head>
<body>
<div id="container"></div>
<script src="https://cdn.rawgit.com/mrdoob/three.js/r92/build/three.min.js"></script>
<script src="https://cdn.rawgit.com/mrdoob/three.js/r92/examples/js/controls/OrbitControls.js"
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
<script src="js/three.js"></script>
<script>
  // create variables of the window width and height
  var WIDTH =window.innerHeight, HEIGHT =window.innerHeight;
  // create the scene
  var scene =new THREE.Scene();
  // set some camera attributes
  //var VIEW_ANGLE = 45, ASPECT = WIDTH / HEIGHT, NEAR = 1, FAR = 1000;
  // set the spec for the camera
  var camera =new THREE.PerspectiveCamera(55 ,window.innerWidth/window.innerHeight , 1,1000
  // set the z position of the camera to 90 so we can see
  // what's going on
  camera.position.z = 100;
  // add the camera
  scene.add(camera);
  // attach the container to the div id container using JQuery
  var view_container =$('#container');
  // check for web compatibility WebGL or canvas
  if (window.WebGLRenderingContext) {
    var renderer =new THREE.WebGLRenderer();
  }else {
    var renderer =new THREE.CanvasRenderer();
  }
  // define the material for the torus knot and
  // the sphere
  var tmaterial =new THREE.MeshLambertMaterial({
    color: 0x00ff00
  });
  var smaterial =new THREE.MeshPhongMaterial(
          { color: 0x00ffff,side:
            THREE.DoubleSide,
            shading:THREE.SmoothShading,
            blending:THREE.AdditiveBlending }
  );
  // set up the geometry for the torus and sphere
  var tgeometry =new THREE.TorusKnotGeometry(3,2,17,8);
  var sphere =new THREE.Mesh(new THREE.SphereGeometry(8,60,60), smaterial);
  var torus_knot =new THREE.Mesh(tgeometry, tmaterial);
  // set the starting postions of both objects
  sphere.position.x = -10;
  sphere.position.y = -10;
  // I was playing with it to get them to start in different
  // area and move independently
  //sphere.position.z = 90;
  // torus_knot.position.x = -8;
  // torus_knot.position.y = -20;
  // torus_knot.position.z = 90;
  // add the knot and sphere to the scene
  scene.add(torus_knot);
  scene.add(sphere);
  // add lighting
  var pLight =new THREE.PointLight( 0xffffff,5,100 );
  pLight.position.set( 50,50,50 );
  scene.add( pLight );
  // set up the camera controls and add a listener for the mouse move
  var cameraControls =new THREE.OrbitControls(camera, renderer.domElement);
  cameraControls.addEventListener( 'mousemove', renderer );
  // set up the size for the renderer
  renderer.setSize(WIDTH, HEIGHT);
  // append the renderer to the div container
  view_container.append(renderer.domElement);
  // loop it
  function animate() {
    requestAnimationFrame(animate);
    render();
  }
  // boolean variables for movement
  var move_right =true;
  var falling =true;
  var move_near =false;
  // move the objectse
  function move_object() {
    if(move_right) {
// move the object to the right
      torus_knot.position.x += .1;
    }else {
// move the object to the left
      torus_knot.position.x -= .1;
    }
    if (falling) {
// move the object down
      torus_knot.position.y -= .1;
    }else {
// move the object up
      torus_knot.position.y += .1;
    }
    if (move_near) {
// move object closer
      torus_knot.position.z -= .1;
    }else {
      torus_knot.position.z += .1;
    }
    if(move_right) {
// move the object to the right
      sphere.position.x += .1;
    }else {
// move the object to the left
      sphere.position.x -= .1;
    }
    if (falling) {
// move the object down
      sphere.position.y -= .1;
    }else {
// move the object up
      sphere.position.y += .1;
    }
    if (move_near) {
// move object closer
      sphere.position.z -= .1;
    }else {
      sphere.position.z += .1;
    }
  }
  // detect the wall limits using the boolean variables
  function detect_wall() {
    if(torus_knot.position.x > 15) {
      change_color_torus();
      move_right =false;
    }else if (torus_knot.position.x < -15) {
      change_color_torus();
      move_right =true;
    }
    if(sphere.position.x > 15) {
      change_color_sphere();
      move_right =false;
    }else if (sphere.position.x < -15) {
      change_color_sphere();
      move_right =true;
    }
  }
  function detect_floor() {
    if (torus_knot.position.y < 0) {
      change_color_torus();
      falling =false;
    }else if (torus_knot.position.y > 19) {
      change_color_torus();
      falling =true;
    }
  }
  function detect_screen(){
    if (torus_knot.position.z < 5) {
      change_color_torus();
      move_near =false;
    }else if (torus_knot.position.z > 40) {
      change_color_torus();
      move_near =true;
    }
  }
  function getRandomColor() {
    var letters ='0123456789ABCDEF';
    var color ='#';
    for (var i= 0; i < 6; i++) {
      color += letters[Math.floor(Math.random() * 16)];
    }
    return color;
  }
  // change the color of the torus
  function change_color_torus() {
    var new_material =new THREE.MeshLambertMaterial({
              color:getRandomColor()
            })
    ;
    torus_knot.material =new_material;
  }
  // change color of the sphere
  function change_color_sphere() {
    var new_material =new THREE.MeshPhongMaterial({
      color:getRandomColor()
    });
    sphere.material =new_material;
  }
  // render the scenes
  function render() {
// call the functions to detect the edges
    detect_wall();
    detect_floor();
    detect_screen();
// I would need to separate this into two
// function move_object_torus and move_object_sphere
// for them to move independently
    move_object();
// rotate the torus knot and the sphere
    torus_knot.rotateOnAxis(new THREE.Vector3(0,0,1), .04);
    torus_knot.rotateOnAxis(new THREE.Vector3(0,1,0), .01);
    sphere.rotateOnAxis(new THREE.Vector3(0,0,1), .02);
    sphere.rotateOnAxis(new THREE.Vector3(0,1,0), .05);
// update camera controls
    cameraControls.update();
// render scene and the camera
    renderer.render(scene, camera);
  }
  // start the animation
  animate();
</script>
</body>
</html>
